//
//  main.cpp
//  Hw5
//
//  Created by Antonio Tsai on 10/04/2017.
//  Copyright Â© 2017 TTU. All rights reserved.
//

#include <iostream>
#include <opencv2/core/core.hpp>
// #include "opencv2/imgcodecs.hpp"
#include <opencv2/imgproc/imgproc.hpp>
// #include "opencv2/videoio.hpp"
#include <opencv2/video/video.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>

using namespace cv;
using namespace std;


// Resource
char* source = (char*)"VID20170410100841.mp4";
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
char keyboard; //input from keyboard

// processVideo
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask generated by MOG2 method
Mat gaussianBlur;
Mat pBinaryImage;
Mat final;
//double learningRate = 0.003;
double learningRate = 0.9;

// Background Subtractor parameter
//int history = 50;
int history = 1;
//float varThreshold = 200;
int varThreshold = 200;
bool bShadowDetection = true;

// GaussianBlur
int _size = 21;

// Threshold
int threshold_value = 20;
int threshold_type = THRESH_BINARY;
int const max_BINARY_value = 255;

// Windows & Trackbar
char* original = (char*)"Frame";
char* masked = (char*)"FG Mask MOG 2";

// Fuctions
void processVideo(char* videoFilename);
void Threshold_Demo( int, void* );


int main(int argc, const char * argv[]) {
    //create GUI windows
    namedWindow(original, 800);
    namedWindow(masked, 800);
    
    //create Background Subtractor objects
    pMOG2 = new BackgroundSubtractorMOG2(history, varThreshold, bShadowDetection); //MOG2 approach
    processVideo(source);
    
    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

void processVideo(char* videoFilename) {
    //create the capture object
//    VideoCapture capture(videoFilename);
    VideoCapture capture(0);
    if(!capture.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }
    
    //read input data. ESC or 'q' for quitting
    keyboard = 0;
    while(keyboard != 'q' && keyboard != 27){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }
        
        //update the background model
        pMOG2->operator()(frame, fgMaskMOG2, learningRate);
        
        // GaussianBlur
        ::GaussianBlur(fgMaskMOG2, gaussianBlur, Size(_size, _size) ,0 ,0);
        
        // cvThreshold
        threshold(gaussianBlur, pBinaryImage, threshold_value, max_BINARY_value, threshold_type);
        
        // Final
        final = pBinaryImage;
//        final = gaussianBlur;
        
        //get the frame number and write it on the current frame
        stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(500,20),
                  cv::Scalar(255,255,255), -1);
        ss << capture.get(CV_CAP_PROP_POS_FRAMES) << " type " << threshold_type << " value" << threshold_value << " history " << history << " varThreshold " << varThreshold;
        string frameNumberString = ss.str();
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
        //show the current frame and the fg masks
        imshow(original, frame);
        //        imshow("FG Mask MOG 2", fgMaskMOG2);
        imshow(masked, final);
        //get the input from the keyboard
        keyboard = (char)waitKey( 30 );
    }
    //delete capture object
    capture.release();
}
